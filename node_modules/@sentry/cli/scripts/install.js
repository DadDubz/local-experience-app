#!/usr/bin/env node

'use strict';

const fs = require('fs');
const os = require('os');
const path = require('path');
const crypto = require('crypto');
const zlib = require('zlib');
const stream = require('stream');
const process = require('process');

const fetch = require('node-fetch');
const HttpsProxyAgent = require('https-proxy-agent');
const ProgressBar = require('progress');
const Proxy = require('proxy-from-env');
const which = require('which');

const helper = require('../js/helper');
const pkgInfo = require('../package.json');
const Logger = require('../js/logger');

const logger = new Logger(getLogStream('stderr'));

const CDN_URL =
  process.env.SENTRYCLI_LOCAL_CDNURL ||
  process.env.npm_config_sentrycli_cdnurl ||
  process.env.SENTRYCLI_CDNURL ||
  'https://downloads.sentry-cdn.com/sentry-cli';

function getLogStream(defaultStream) {
  const logStream = process.env.SENTRYCLI_LOG_STREAM || defaultStream;

  if (logStream === 'stdout') {
    return process.stdout;
  }

  if (logStream === 'stderr') {
    return process.stderr;
  }

  throw new Error(
    `Incorrect SENTRYCLI_LOG_STREAM env variable. Possible values: 'stdout' | 'stderr'`
  );
}

function shouldRenderProgressBar() {
  const silentFlag = process.argv.some((v) => v === '--silent');
  const silentConfig = process.env.npm_config_loglevel === 'silent';
  const silentEnv = process.env.SENTRYCLI_NO_PROGRESS_BAR;
  const ciEnv = process.env.CI === 'true' || process.env.CI === '1';
  const notTTY = !process.stdout.isTTY;
  // If any of possible options is set, skip rendering of progress bar
  return !(silentFlag || silentConfig || silentEnv || ciEnv || notTTY);
}

function getDownloadUrl(platform, arch) {
  const releasesUrl = `${CDN_URL}/${pkgInfo.version}/sentry-cli`;
  let archString = '';
  switch (arch) {
    case 'x64':
      archString = 'x86_64';
      break;
    case 'x86':
    case 'ia32':
      archString = 'i686';
      break;
    case 'arm64':
      archString = 'aarch64';
      break;
    case 'arm':
      archString = 'armv7';
      break;
    default:
      archString = arch;
  }
  switch (platform) {
    case 'darwin':
      return `${releasesUrl}-Darwin-universal`;
    case 'win32':
      // Windows arm machines can run x64 binaries
      if (arch === 'arm64') {
        archString = 'x86_64';
      }
      return `${releasesUrl}-Windows-${archString}.exe`;
    case 'linux':
    case 'freebsd':
      return `${releasesUrl}-Linux-${archString}`;
    default:
      return null;
  }
}

function createProgressBar(name, total) {
  const incorrectTotal = typeof total !== 'number' || Number.isNaN(total);

  if (incorrectTotal || !shouldRenderProgressBar()) {
    return {
      tick: () => {},
    };
  }

  const logStream = getLogStream('stdout');

  if (logStream.isTTY) {
    return new ProgressBar(`fetching ${name} :bar :percent :etas`, {
      complete: '█',
      incomplete: '░',
      width: 20,
      total,
    });
  }

  let pct = null;
  let current = 0;
  return {
    tick: (length) => {
      current += length;
      const next = Math.round((current / total) * 100);
      if (next > pct) {
        pct = next;
        logStream.write(`fetching ${name} ${pct}%\n`);
      }
    },
  };
}

function npmCache() {
  const keys = ['npm_config_cache', 'npm_config_cache_folder', 'npm_config_yarn_offline_mirror'];

  for (let key of [...keys, ...keys.map((k) => k.toUpperCase())]) {
    if (process.env[key]) return process.env[key];
  }

  if (process.env.APPDATA) {
    return path.join(process.env.APPDATA, 'npm-cache');
  }

  return path.join(os.homedir(), '.npm');
}

function getCachedPath(url) {
  const digest = crypto.createHash('md5').update(url).digest('hex').slice(0, 6);

  return path.join(
    npmCache(),
    'sentry-cli',
    `${digest}-${path.basename(url).replace(/[^a-zA-Z0-9.]+/g, '-')}`
  );
}

function getTempFile(cached) {
  return `${cached}.${process.pid}-${Math.random().toString(16).slice(2)}.tmp`;
}

function validateChecksum(tempPath, name) {
  let storedHash;
  try {
    const checksums = fs.readFileSync(path.join(__dirname, '../checksums.txt'), 'utf8');
    const entries = checksums.split('\n');
    for (let i = 0; i < entries.length; i++) {
      const [key, value] = entries[i].split('=');
      if (key === name) {
        storedHash = value;
        break;
      }
    }
  } catch (e) {
    logger.log(
      'Checksums are generated when the package is published to npm. They are not available directly in the source repository. Skipping validation.'
    );
    return;
  }

  if (!storedHash) {
    logger.log(`Checksum for ${name} not found, skipping validation.`);
    return;
  }

  const currentHash = crypto.createHash('sha256').update(fs.readFileSync(tempPath)).digest('hex');

  if (storedHash !== currentHash) {
    fs.unlinkSync(tempPath);
    throw new Error(
      `Checksum validation for ${name} failed.\nExpected: ${storedHash}\nReceived: ${currentHash}`
    );
  } else {
    logger.log('Checksum validation passed.');
  }
}

async function downloadBinary() {
  const arch = os.arch();
  const platform = os.platform();
  const outputPath = helper.getFallbackBinaryPath();

  if (process.env.SENTRYCLI_USE_LOCAL === '1') {
    try {
      const binPaths = which.sync('sentry-cli', { all: true });
      if (!binPaths.length) throw new Error('Binary not found');
      const binPath = binPaths[binPaths.length - 1];
      logger.log(`Using local binary: ${binPath}`);
      fs.copyFileSync(binPath, outputPath);
      return Promise.resolve();
    } catch (e) {
      throw new Error(
        'Configured installation of local binary, but it was not found.' +
          'Make sure that `sentry-cli` executable is available in your $PATH or disable SENTRYCLI_USE_LOCAL env variable.'
      );
    }
  }

  const downloadUrl = getDownloadUrl(platform, arch);
  if (!downloadUrl) {
    throw new Error(`Unsupported target ${platform}-${arch}`);
  }

  const cachedPath = getCachedPath(downloadUrl);
  if (fs.existsSync(cachedPath)